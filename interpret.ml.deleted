(**** the old definition of GetIndex   of varexp * expr ***)

    | Variable(var) ->
        let locals, globals, entities = env in
        (match var with
          VarExp(id, scope) ->
            (match scope with
              Local ->
                if NameMap.mem origexp locals then
                  (NameMap.find origexp locals), env
                else raise (Failure ("undeclared local variable " ^ id))
            | Global ->
                if NameMap.mem origexp globals then
                  (NameMap.find origexp globals), env
                else raise (Failure ("undeclared global variable " ^ id))
            | Entity ->
                if NameMap.mem origexp entities then
                  (NameMap.find origexp entities), env
                else raise (Failure ("undeclared CardEntity variable " ^ id))
            )
        | GetIndex(vexp, idx) ->
            let evalvexp, env = eval env (Variable(vexp)) in
            let evalidx, env = eval env idx in
            (match evalvexp, evalidx with
              Variable(VarExp(id, Local)), IntLiteral(i) ->
                let key = (Variable(GetIndex(VarExp(id, Local), evalidx))) in
                if NameMap.mem key locals then
                  (NameMap.find key locals), env
                else raise (Failure ("local list dereference of " ^ id^"["^string_of_int i^"] without initializing that index"))
            | Variable(VarExp(id, Global)), IntLiteral(i) ->
                let key = (Variable(GetIndex(VarExp(id, Global), evalidx))) in
                if NameMap.mem key globals then
                  (NameMap.find key globals), env
                else raise (Failure ("global list dereference of " ^ id^"["^string_of_int i^"] without initializing that index"))
            | (* TODO the case where it's a GetIndex (multi-dimensional lists) *)
            | _, _ ->
                raise (Failure ("invalid list dereference, probably using non-integer index"))
            ))

    | Assign(var, e) ->
        let v, (locals, globals, entities) = eval env e in
        (match var with
          VarExp(id, scope) ->
            let varkey = (Variable(var)) in
            (match scope with
              Local ->
                if NameMap.mem varkey locals then
                  v, (NameMap.add varkey v locals, globals, entities)
                else raise (Failure ("undeclared local variable " ^ id))
            | Global ->
                if NameMap.mem varkey globals then
                  v, (locals, NameMap.add varkey v globals, entities)
                else raise (Failure ("undeclared global variable " ^ id))
            | Entity ->
                (* XXX are entities assigned this way too? *)
                if NameMap.mem varkey entities then
                  v, (locals, globals, NameMap.add varkey v entities)
                else raise (Failure ("undeclared CardEntity " ^ id))
            )
        | GetIndex(vexp, idx) ->
            let evalvexp, env = eval env (Variable(vexp)) in
            let evalidx, env = eval env idx in
            (match evalvexp, evalidx with
              (* The key is the evaluated Variable expression *)
              Variable(VarExp(id, Local)), IntLiteral(i) ->
                let key = (Variable(GetIndex(VarExp(id, Local), evalidx))) in
                if NameMap.mem key locals then
                  (NameMap.find key locals), env
                else raise (Failure ("local list dereference of " ^ id^"["^string_of_int i^"] without initializing that index"))
            | Variable(VarExp(id, Global)), IntLiteral(i) ->
                let key = (Variable(GetIndex(VarExp(id, Global), evalidx))) in
                if NameMap.mem key globals then
                  (NameMap.find key globals), env
                else raise (Failure ("global list dereference of " ^ id^"["^string_of_int i^"] without initializing that index"))
            | (* TODO the case where it's a GetIndex (multi-dimensional lists) *)
            | _, _ ->
                raise (Failure ("invalid list dereference, probably using non-integer index"))
            ))
(*******)


  (* Execute a statement and return an updated environment *)
  (* TODO add the rest of our statements *)
  let rec exec env = function
      Block(stmts) -> List.fold_left exec env stmts
    | Expr(e) -> let _, env = eval env e in env
    | If(e, s1, s2) ->
        let v, env = eval env e in
        exec env (if v != 0 then s1 else s2)
    | While (e, s) ->
        let rec loop env =
          let v, env = eval env e in
          if v != 0 then loop (exec env s) else env
        in loop env
    | For(e1, e2, e3, s) ->
        let _, env = eval env e1 in
        let rec loop env =
          let v, env = eval env e2 in
          if v!= 0 then
            let _, env = eval (exec env s) e3 in
            loop env
          else
            env
        in loop env
    | Return(e) ->
        let v, (locals, globals) = eval env e in
        raise (ReturnException(v, globals))
  in
  (* end of statement execution *)

  (* call: enter the function: bind actual values to formal args *)
  (* XXX make sure globals are bound correctly when entering a function. probably this section *)
  let locals =
    try List.fold_left2
      (fun locals formal actual -> NameMap.add formal actual locals)
      NameMap.empty fdecl.formals actuals
    with Invalid_argument(_) ->
      raise (Failure ("wrong number of arguments to " ^ fdecl.fname))
  in
  let locals = List.fold_left   (* Set local variables to 0 *)
      (fun locals local -> NameMap.add local 0 locals)
      locals fdecl.locals
  in   (* Execute each statement; return updated global symbol table *)
  snd (List.fold_left exec (locals, globals) fdecl.body)

(* run: set global variables to 0; find and run "start" *)
(* TODO instead of setting global vars to 0, read them from the globals block *)
in let globals = List.fold_left
    (fun globals vdecl -> NameMap.add vdecl 0 globals)
    NameMap.empty vars
in try
  call (NameMap.find "start" func_decls) [] globals
with Not_found ->
  raise (Failure ("did not find the start() function"))


